/**
 * Worker script template for serving static files from R2 with Cache API.
 * Phase 2: R2 serving with edge caching and configurable TTL.
 */

/**
 * Generate the Worker script code for serving static files from R2 with Cache API.
 *
 * @param bucketBinding - The R2 bucket binding name (e.g., "R2_BUCKET")
 * @returns The Worker script code as a string
 */
export function generateWorkerScript(bucketBinding: string): string {
	return `
/**
 * WorkerSite - Static file server with R2 backend and Cache API
 * Generated by @jmmaloney4/sector7 WorkerSite component
 * Phase 2: Edge caching with configurable TTL
 */

export default {
	async fetch(request, env, ctx) {
		const url = new URL(request.url);

		// 1. Path normalization - remove leading slash
		let objectKey = url.pathname.slice(1);

		// 2. Directory index handling
		if (objectKey === '' || objectKey.endsWith('/')) {
			objectKey += 'index.html';
		}

		// 3. Cache API check (requires custom domain)
		const cache = caches.default;
		const cacheKey = new Request(url.toString(), request);
		let response = await cache.match(cacheKey);

		if (response) {
			// Cache HIT - return immediately with debug header
			const headers = new Headers(response.headers);
			headers.set('X-Cache-Status', 'HIT');
			return new Response(response.body, {
				status: response.status,
				statusText: response.statusText,
				headers,
			});
		}

		// 4. Cache MISS - fetch from R2
		const object = await env.${bucketBinding}.get(objectKey);

		// 5. Handle 404
		if (!object) {
			return new Response('Not Found', { status: 404 });
		}

		// 6. Build response with metadata
		response = createResponse(object, objectKey, 200, 'MISS', env);

		// 7. Async cache storage (non-blocking)
		// Clone response because R2 body streams are single-use
		ctx.waitUntil(cache.put(cacheKey, response.clone()));

		return response;
	},
};

/**
 * Create HTTP Response from R2 object with proper headers
 */
function createResponse(object, objectKey, status, cacheStatus, env) {
	const headers = new Headers();

	// Content-Type from R2 metadata
	if (object.httpMetadata?.contentType) {
		headers.set('Content-Type', object.httpMetadata.contentType);
	} else {
		// Fallback based on file extension
		const contentType = guessContentType(objectKey);
		headers.set('Content-Type', contentType);
	}

	// ETag for cache validation
	headers.set('ETag', object.httpEtag);

	// Cache-Control with configurable TTL
	const maxAge = env.CACHE_TTL_SECONDS || '31536000';
	headers.set('Cache-Control', \`public, max-age=\${maxAge}, immutable\`);

	// Last-Modified
	if (object.uploaded) {
		headers.set('Last-Modified', object.uploaded.toUTCString());
	}

	// Observability header
	headers.set('X-Cache-Status', cacheStatus);

	return new Response(object.body, { status, headers });
}

/**
 * Guess content type from file extension
 */
function guessContentType(key) {
	const ext = key.split('.').pop()?.toLowerCase();
	const types = {
		html: 'text/html; charset=utf-8',
		css: 'text/css; charset=utf-8',
		js: 'application/javascript; charset=utf-8',
		json: 'application/json; charset=utf-8',
		png: 'image/png',
		jpg: 'image/jpeg',
		jpeg: 'image/jpeg',
		gif: 'image/gif',
		svg: 'image/svg+xml',
		ico: 'image/x-icon',
		woff: 'font/woff',
		woff2: 'font/woff2',
		ttf: 'font/ttf',
		eot: 'application/vnd.ms-fontobject',
		pdf: 'application/pdf',
		txt: 'text/plain; charset=utf-8',
		webp: 'image/webp',
		avif: 'image/avif',
		mp4: 'video/mp4',
		webm: 'video/webm',
	};
	return types[ext || ''] || 'application/octet-stream';
}
`.trim();
}
