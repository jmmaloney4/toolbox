/**
 * Worker script template for serving static files from R2 with Cache API.
 * Phase 2: R2 serving with edge caching and configurable TTL.
 */

/**
 * Generate the Worker script code for serving static files from R2 with Cache API.
 *
 * @param bucketBinding - The R2 bucket binding name (e.g., "R2_BUCKET")
 * @param prefix - Optional prefix to prepend to all R2 object keys
 * @returns The Worker script code as a string
 */
export function generateWorkerScript(
	bucketBinding: string,
	prefix?: string,
): string {
	// Sanitize prefix to prevent code injection
	const sanitizedPrefix = prefix
		? JSON.stringify(prefix).slice(1, -1)
		: undefined;

	return `
/**
 * WorkerSite - Static file server with R2 backend and Cache API
 * Generated by @jmmaloney4/sector7 WorkerSite component
 * Phase 2: Edge caching with configurable TTL
 */

export default {
	async fetch(request, env, ctx) {
		try {
			const url = new URL(request.url);

			// 1. Path normalization - remove leading slash
			let objectKey = url.pathname.slice(1);

			// 2. Directory index handling
			if (objectKey === '' || objectKey.endsWith('/')) {
				objectKey += 'index.html';
			}

			// 2.5. Prepend prefix if configured
			${sanitizedPrefix ? `objectKey = '${sanitizedPrefix}/' + objectKey;` : "// No prefix configured"}

			// 3. Cache API check (requires custom domain)
			const cache = caches.default;
			const cacheKey = new Request(url.toString(), { method: 'GET' });
			let response = await cache.match(cacheKey);

			if (response) {
				// Cache HIT - return immediately with debug header
				const headers = new Headers(response.headers);
				headers.set('X-Cache-Status', 'HIT');
				return new Response(response.body, {
					status: response.status,
					statusText: response.statusText,
					headers,
				});
			}

			// 4. Cache MISS - fetch from R2
			const object = await env.${bucketBinding}.get(objectKey);

			// 5. Handle 404
			if (!object) {
				return new Response('Not Found', { status: 404 });
			}

			// 6. Build response with metadata
			response = createResponse(object, objectKey, 200, 'MISS', env);

			// 7. Async cache storage (non-blocking)
			// Clone response because R2 body streams are single-use
			ctx.waitUntil(cache.put(cacheKey, response.clone()));

			return response;
		} catch (error) {
			// Log error for debugging (visible in Workers logs)
			console.error('WorkerSite error:', error);

			// Return 500 error to client
			return new Response('Internal Server Error', {
				status: 500,
				headers: { 'Content-Type': 'text/plain' }
			});
		}
	},
};

/**
 * Create HTTP Response from R2 object with proper headers
 */
function createResponse(object, objectKey, status, cacheStatus, env) {
	const headers = new Headers();

	// Content-Type from R2 metadata
	if (object.httpMetadata?.contentType) {
		headers.set('Content-Type', object.httpMetadata.contentType);
	} else {
		// Fallback based on file extension
		const contentType = guessContentType(objectKey);
		headers.set('Content-Type', contentType);
	}

	// ETag for cache validation
	headers.set('ETag', object.httpEtag);

	// Cache-Control with configurable TTL
	const maxAge = env.CACHE_TTL_SECONDS || '31536000';
	headers.set('Cache-Control', \`public, max-age=\${maxAge}, immutable\`);

	// Last-Modified
	if (object.uploaded) {
		headers.set('Last-Modified', object.uploaded.toUTCString());
	}

	// Observability header
	headers.set('X-Cache-Status', cacheStatus);

	return new Response(object.body, { status, headers });
}

/**
 * Guess content type from file extension
 */
function guessContentType(key: string) {
	// Get the basename (after last '/')
	const base = key.substring(key.lastIndexOf('/') + 1);
	const dot = base.lastIndexOf('.');
	const ext = (dot > 0) ? base.substring(dot + 1).toLowerCase() : '';
	const types = {
		html: 'text/html; charset=utf-8',
		css: 'text/css; charset=utf-8',
		js: 'application/javascript; charset=utf-8',
		json: 'application/json; charset=utf-8',
		png: 'image/png',
		jpg: 'image/jpeg',
		jpeg: 'image/jpeg',
		gif: 'image/gif',
		svg: 'image/svg+xml',
		ico: 'image/x-icon',
		woff: 'font/woff',
		woff2: 'font/woff2',
		ttf: 'font/ttf',
		eot: 'application/vnd.ms-fontobject',
		pdf: 'application/pdf',
		txt: 'text/plain; charset=utf-8',
		webp: 'image/webp',
		avif: 'image/avif',
		mp4: 'video/mp4',
		webm: 'video/webm',
	};
	return types[ext || ''] || 'application/octet-stream';
}
`.trim();
}
