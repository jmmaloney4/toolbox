# Nix Flake Detect Action
#
# Detects Nix flake outputs and generates a build matrix for uncached derivations.
# Uses nix-eval-jobs to probe cache status and builds a matrix of work needed.
#
# Usage:
# ```yaml
# - uses: jmmaloney4/workflows/.github/actions/nix-flake-detect@main
#   id: detect
#   with:
#     probe-timeout: 180
#     cache-version: "v1"
# - name: Use matrix
#   run: echo '${{ steps.detect.outputs.matrix_include }}'
# ```

name: 'Nix Flake Detect'
description: 'Detect Nix flake outputs and generate build matrix for uncached derivations'

inputs:
  probe-timeout:
    description: 'Timeout in seconds for cache probing'
    required: false
    default: '180'
  cache-key:
    description: 'Cache key for Nix evaluation cache (from warm-cache job)'
    required: true
  working-directory:
    description: 'Working directory to search for flake'
    required: false
    default: '.'

outputs:
  matrix-include:
    description: 'JSON matrix of uncached outputs that need building'
    value: ${{ steps.compute.outputs.matrix_include }}
  has-work:
    description: 'Whether there are any uncached outputs to build'
    value: ${{ steps.compute.outputs.has_work }}
  all-outputs:
    description: 'JSON array of all detected outputs (cached and uncached)'
    value: ${{ steps.compute.outputs.all_outputs }}

runs:
  using: 'composite'
  steps:
  - name: Restore eval/source caches
    uses: actions/cache/restore@v4
    with:
      path: |
        ~/.cache/nix/eval-cache-v5
        ~/.cache/nix/fetcher-cache-v1.sqlite
        ~/.cache/nix/git
        ~/.cache/nix/tarballs
      key: ${{ inputs.cache-key }}

  - name: Compute build-needed matrix via nix-eval-jobs
    id: compute
    shell: bash
    working-directory: ${{ inputs.working-directory }}
    env:
      PROBE_TIMEOUT_SECONDS: ${{ inputs.probe-timeout }}
    run: |
      set -euo pipefail

      echo "=== Nix Flake Detection ==="
      echo "Probe timeout: ${PROBE_TIMEOUT_SECONDS}s"
      echo "Working directory: $(pwd)"

      # Detect current Nix system
      system="$(nix eval --impure --raw --expr 'builtins.currentSystem')"
      echo "System: $system"

      # Cache flake metadata once
      flake_meta_json_tmp="$(mktemp)"
      nix flake show --json > "$flake_meta_json_tmp"
      echo "Flake metadata cached"

      # Helper function: stream all attributes for a category/system as JSON with cache status
      all_for() {
        local category="$1"
        local system_="$2"
        local target=".#${category}.${system_}"

        echo "nix-eval-jobs: $target" >&2

        # Only evaluate categories that exist for this system
        local cat_exists sys_exists
        cat_exists=$(nix eval --impure --raw --expr "let fl = builtins.getFlake (toString ./.); in if (builtins.hasAttr \"${category}\" fl) then \"1\" else \"0\"")
        if [ "$cat_exists" != "1" ]; then
          return 0
        fi
        sys_exists=$(nix eval --impure --raw --expr "let fl = builtins.getFlake (toString ./.); in if (builtins.hasAttr \"${system_}\" fl.${category}) then \"1\" else \"0\"")
        if [ "$sys_exists" != "1" ]; then
          return 0
        fi

        # Query cache status; use timeout to avoid hanging
        if ! out=$(timeout "${PROBE_TIMEOUT_SECONDS}s" nix run nixpkgs#nix-eval-jobs -- --check-cache-status --flake "$target" 2>/dev/null || echo ""); then
          echo "::warning title=Cache check failed::nix-eval-jobs failed for $target, assuming not cached" >&2
          # Fallback: assume not cached if we can't check
          nix eval --json --expr "
            let
              flake = builtins.getFlake (toString ./.);
              attrs = flake.${category}.${system_};
            in
              builtins.mapAttrs (name: drv: {
                category = \"${category}\";
                system = \"${system_}\";
                name = name;
                flake_attr = \".#${category}.${system_}.\" + name;
                cached = false;
                store_path = if builtins.isDerivation drv then drv.outPath or \"unknown\" else \"not-a-derivation\";
              }) attrs
          " | nix run nixpkgs#jq -- -c '.[]'
          return 0
        fi

        # Get store paths for all attributes
        local store_paths_json
        store_paths_json=$(nix eval --json --expr "
          let
            flake = builtins.getFlake (toString ./.);
            attrs = flake.${category}.${system_};
          in
            builtins.mapAttrs (name: drv:
              if builtins.isDerivation drv then drv.outPath or \"unknown\"
              else \"not-a-derivation\"
            ) attrs
        " 2>/dev/null || echo '{}')

        # Emit JSON lines with cache status
        printf '%s' "$out" \
          | nix run nixpkgs#jq -- -rc \
              --arg category "$category" \
              --arg system "$system_" \
              --argjson store_paths "$store_paths_json" '
                {
                  category: $category,
                  system: $system,
                  name: (.attr // "default"),
                  flake_attr: (".#" + $category + "." + $system + "." + (.attr // "default")),
                  cached: ((.cacheStatus=="cached") or (.cached==true) or (.isCached==true)),
                  store_path: ($store_paths[.attr // "default"] // "unknown")
                }
              '
      }

      # Collect all outputs into a temp file
      tmp_all="$(mktemp)"
      echo "Detecting flake outputs..."
      
      nix run nixpkgs#jq -- -r 'keys[]' "$flake_meta_json_tmp" \
        | while IFS= read -r category; do
            all_for "$category" "$system"
          done > "$tmp_all"

      # Build arrays from collected data
      all_outputs=$(nix run nixpkgs#jq -- -sc '[.[]]' "$tmp_all")
      include_array=$(nix run nixpkgs#jq -- -sc 'map(select(.cached==false) | {category, system, name, flake_attr})' "$tmp_all")
      has_work=$(nix run nixpkgs#jq -- -rc 'if (length>0) then "true" else "false" end' <<<"$include_array")

      echo "All detected outputs: $all_outputs"
      echo "Computed include (uncached only): $include_array"
      echo "Has work: $has_work"

      # Set outputs using proper format
      {
        echo "matrix_include<<EOF"
        echo "$include_array"
        echo "EOF"
        echo "all_outputs<<EOF"
        echo "$all_outputs"
        echo "EOF"
        echo "has_work=$has_work"
      } >> "$GITHUB_OUTPUT"

      # Cleanup temp files
      rm -f "$tmp_all" "$flake_meta_json_tmp"

      # Write summary to GitHub Actions
      {
        echo "### ðŸ” Detected Nix flake outputs"
        echo ""
        if [ -n "$all_outputs" ] && [ "$all_outputs" != "null" ] && [ "$all_outputs" != "[]" ]; then
          echo "**System:** \`$system\`"
          echo ""
          echo "| Category | System | Name | Attr | Store Path | Cached |"
          echo "|---|---|---|---|---|---|"
          
          # Use jq to format the table safely
          if echo "$all_outputs" | jq -e . >/dev/null 2>&1; then
            echo "$all_outputs" | nix run nixpkgs#jq -- -rc '
              .[] | "| " + .category + " | " + .system + " | **" + .name + "** | `" + .flake_attr + "` | `" + ((.store_path | split("/") | last) // "unknown") + "` | " + (if .cached then "ðŸ“¦ yes" else "ðŸ—ï¸ no" end) + " |"
            '
          else
            echo "| Error | Could not parse outputs | - | - | - | - |"
          fi
          
          echo ""
          uncached_count=$(echo "$include_array" | nix run nixpkgs#jq -- -r 'length')
          total_count=$(echo "$all_outputs" | nix run nixpkgs#jq -- -r 'length')
          echo "ðŸ“Š **Summary:** $uncached_count/$total_count outputs need building"
        else
          echo "âŒ No outputs detected for this system."
          echo ""
          echo "This could mean:"
          echo "- No flake outputs are defined for \`$system\`"
          echo "- The flake evaluation failed"
          echo "- The flake.nix file is not present"
        fi
        echo ""
        echo "_Detection completed at $(date -u '+%Y-%m-%d %H:%M:%S UTC')_"
      } >> "$GITHUB_STEP_SUMMARY"