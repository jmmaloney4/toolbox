name: '‚ùÑÔ∏è nix'
on:
  workflow_call:
    inputs:
      runs-on:
        description: 'Runner type for all jobs'
        required: true
        type: string
      repository:
        description: 'Repository to checkout and build (format: owner/repo)'
        required: true
        type: string
      ref:
        description: 'Git ref to checkout and build'
        required: true
        type: string

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write

jobs:
  # NOTE: Warm Nix evaluation/fetch caches once per workflow to avoid re-downloading
  # nixpkgs and other flake inputs in every matrix job. Each matrix build re-evaluates
  # the flake and resolves inputs; without a shared cache, this causes repeated network
  # fetches and slower evaluations. We key this cache by OS and flake.lock to ensure
  # correctness across input changes, and we restore it in all build jobs. This is a
  # complementary optimization to binary caches (substituters); it only speeds up
  # evaluation and source fetch, not the actual builds.
  warm-cache:
    name: "üî• warm nix eval cache"
    runs-on: ${{ inputs.runs-on }}
    outputs:
      cache_key: ${{ steps.compute-key.outputs.cache_key }}
    steps:
    - uses: actions/checkout@v4
      with:
        repository: ${{ inputs.repository }}
        ref: ${{ inputs.ref }}
    - uses: DeterminateSystems/nix-installer-action@main
    - uses: DeterminateSystems/flakehub-cache-action@main
    - name: compute cache key
      id: compute-key
      shell: bash
      run: |
        set -euo pipefail
        # Use Nix system (e.g., aarch64-darwin, x86_64-linux) instead of runner OS for correctness
        system="$(nix -L eval --impure --raw --expr 'builtins.currentSystem')"
        echo "Nix system: $system"
        lock_hash="${{ hashFiles('flake.lock') }}"
        echo "cache_key=nix-eval-${system}-${lock_hash}-v1" >> "$GITHUB_OUTPUT"
    - name: restore eval/source caches
      id: evalcache-restore
      uses: actions/cache/restore@v4
      with:
        path: |
          ~/.cache/nix/eval-cache-v5
          ~/.cache/nix/fetcher-cache-v1.sqlite
          ~/.cache/nix/git
          ~/.cache/nix/tarballs
        key: ${{ steps.compute-key.outputs.cache_key }}
    - name: warm nix eval caches
      if: steps.evalcache-restore.outputs.cache-hit != 'true'
      shell: bash
      run: |
        set -euo pipefail
        nix -L eval --impure --raw --expr 'builtins.currentSystem' >/dev/null
        nix -L flake show --json >/dev/null
    - name: save eval/source caches
      if: steps.evalcache-restore.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: |
          ~/.cache/nix/eval-cache-v5
          ~/.cache/nix/fetcher-cache-v1.sqlite
          ~/.cache/nix/git
          ~/.cache/nix/tarballs
        key: ${{ steps.compute-key.outputs.cache_key }}
  detect:
    name: '‚òÉÔ∏è detect flake outputs'
    needs: [warm-cache]
    runs-on: ${{ inputs.runs-on }}
    outputs:
      matrix_include: ${{ steps.compute.outputs.matrix_include }}
      has_work: ${{ steps.compute.outputs.has_work }}
    steps:
    - uses: actions/checkout@v4
      with:
        repository: ${{ inputs.repository }}
        ref: ${{ inputs.ref }}
    - uses: DeterminateSystems/nix-installer-action@main
    - uses: DeterminateSystems/flakehub-cache-action@main
    - name: restore eval/source caches
      uses: actions/cache/restore@v4
      with:
        path: |
          ~/.cache/nix/eval-cache-v5
          ~/.cache/nix/fetcher-cache-v1.sqlite
          ~/.cache/nix/git
          ~/.cache/nix/tarballs
        key: ${{ needs.warm-cache.outputs.cache_key }}
    - name: compute build-needed matrix via nix-eval-jobs
      id: compute
      uses: ./.github/actions/compute-flake-build-matrix
      with:
        probe-timeout-seconds: '180'
  build:
    name: "üë∑‚Äç‚ôÇÔ∏è ${{ matrix.category }}.${{ matrix.system }}.${{ matrix.name }}"
    needs: [detect, warm-cache]
    runs-on: ${{ inputs.runs-on }}
    if: ${{ needs.detect.outputs.has_work == 'true' }}
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        include: ${{ fromJson(needs.detect.outputs.matrix_include) }}
    steps:
    - uses: actions/checkout@v4
      with:
        repository: ${{ inputs.repository }}
        ref: ${{ inputs.ref }}
    - uses: DeterminateSystems/nix-installer-action@main
    - uses: DeterminateSystems/flakehub-cache-action@main
    - name: restore eval/source caches
      uses: actions/cache/restore@v4
      with:
        path: |
          ~/.cache/nix/eval-cache-v5
          ~/.cache/nix/fetcher-cache-v1.sqlite
          ~/.cache/nix/git
          ~/.cache/nix/tarballs
        key: ${{ needs.warm-cache.outputs.cache_key }}
    # probe step removed; nix-fast-build --skip-cached handles cache detection
    - name: "üöÄ build with nix-fast-build"
      if: ${{ matrix.noop != 'true' }}
      shell: 'nix -L shell nixpkgs#nix-fast-build -c bash {0}'
      run: |-
        set -euo pipefail
        attr='${{ matrix.flake_attr }}'
        echo "Building via nix-fast-build: $attr"
        # Build only missing (uncached) derivations, with CI-friendly logs and no out-link
        nix-fast-build --skip-cached --no-nom --no-link --flake "$attr"